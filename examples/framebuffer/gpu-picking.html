<!DOCTYPE html>
<html lang="en">
    <head>
        <title>EyeGL â€¢ Gpu Picking</title>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
        <meta name='viewport' content='width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0'>
        <link rel="icon" type="image/png" href="../../files/logo/favicon.png" />
        <link rel="stylesheet" href="../main.css" />
    </head>
    <body>
        <div class="Info">Gpu Picking</div>

        <script src="../imports.js"></script>

        <script type="module">
            import * as IGL from 'eyegl';
            import { Gooey } from 'suey';

            const vertex = /* glsl */ `
                attribute vec2 uv;
                attribute vec3 position;
                attribute vec3 normal;

                // Add instanced attributes just like any attribute
                attribute vec3 offset;
                attribute vec3 random;
                attribute vec4 id;

                uniform mat4 modelViewMatrix;
                uniform mat4 projectionMatrix;
                uniform float uTime;

                varying vec2 vUv;
                varying vec3 vNormal;
                varying vec4 vId;

                void rotate2d(inout vec2 v, float a){
                    mat2 m = mat2(cos(a), -sin(a), sin(a),  cos(a));
                    v = m * v;
                }

                void main() {
                    vUv = uv;
                    vId = id;
                    vNormal = normal;

                    // copy position so that we can modify the instances
                    vec3 pos = position;

                    // scale first
                    pos *= 0.9 + random.y * 0.2;

                    // rotate around y axis
                    rotate2d(pos.xz, random.x * 6.28 + 4.0 * uTime * (random.y - 0.5));

                    pos += offset;

                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                }
            `;

            const fragment = /* glsl */ `
                precision highp float;

                uniform float uTime;

                // Re-use same program to render pick-texture
                uniform bool uTargetRender;

                varying vec2 vUv;
                varying vec4 vId;
                varying vec3 vNormal;

                void main() {
                    if (uTargetRender) {
                        gl_FragColor = vId;
                        return;
                    }

                    vec3 normal = normalize(vNormal);
                    float lighting = dot(normal, normalize(vec3(-0.3, 0.8, 0.6)));
                    gl_FragColor.rgb = vec3(0.2, 0.8, 1.0) + lighting * 0.1;
                    gl_FragColor.a = 1.0;
                }
            `;

            // Scene

            const renderer = new IGL.Renderer({ dpr: 2 });
            const gl = renderer.gl;
            document.body.appendChild(gl.canvas);

            const camera = new IGL.Camera({ fov: 15, position: [0, 0, 10] });
            const target = new IGL.RenderTarget();

            function resize() {
                renderer.setSize(window.innerWidth, window.innerHeight);
                camera.perspective({ aspect: gl.canvas.width / gl.canvas.height });
                target.setSize(gl.canvas.width, gl.canvas.height);
            }
            window.addEventListener('resize', resize);
            resize();

            const scene = new IGL.Transform();

            const program = new IGL.Program({
                vertex,
                fragment,
                uniforms: {
                    uTime: { value: 0 },
                    uTargetRender: { value: 0 },
                },
            });

            const objects = [];
            const num = 20;
            const offsetData = new Float32Array(num * 3);
            const randomData = new Float32Array(num * 3);
            const idData = new Float32Array(num * 4);

            for (let i = 0; i < num; i++) {
                const offset = [ Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1 ];
                offsetData.set(offset, i * 3);
                const id = i + 1;
                idData.set([ ((id >> 0) & 0xff) / 0xff, ((id >> 8) & 0xff) / 0xff, ((id >> 16) & 0xff) / 0xff, ((id >> 24) & 0xff) / 0xff ], i * 4);
                const random = [ Math.random(), Math.random(), Math.random() ];
                randomData.set(random, i * 3);
                objects.push({ id, offset, random });
            }

            const geometry = new IGL.Box({
                width: 0.2,
                height: 0.2,
                depth: 0.2,
                attributes: {
                    offset: { instanced: 1, size: 3, data: offsetData },
                    random: { instanced: 1, size: 3, data: randomData },
                    id: { instanced: 1, size: 4, data: idData },    // to recognize the instance later
                },
            });

            const mesh = new IGL.Mesh({ geometry, program });
            scene.addChild(mesh);

            // 2x2 data texture with 4 colors
            const texture = new IGL.Texture({
                image: new Uint8Array([ 191, 25, 54, 255, 96, 18, 54, 255, 96, 18, 54, 255, 37, 13, 53, 255 ]),
                width: 2,
                height: 2,
                magFilter: gl.NEAREST,
            });

            const highlight = new IGL.Mesh({
                geometry: new IGL.Box({ width: 0.2, height: 0.2, depth: 0.2 }),
                program: new IGL.Uber({
                    normalIntensity: 0,
                    tint: new IGL.Color(1, 0, 0),
                    tintIntensity: 1.0,
                    texture: texture,
                }),
            });
            scene.addChild(highlight);
            highlight.visible = false;

            // Mouse Move

            window.addEventListener('load', () => {
                document.addEventListener('mousemove', move);
                document.addEventListener('touchmove', move);
            });

            const mouse = new IGL.Vec3();
            function move(event) {
                const x = (event.x * gl.canvas.width) / gl.canvas.clientWidth;
                const y = gl.canvas.height - (event.y * gl.canvas.height) / gl.canvas.clientHeight - 1;
                mouse.set(x, y);
            }

            // Render

            gl.clearColor(0, 0, 0, 0);

            const debug = new IGL.Debug();
            requestAnimationFrame(update);
            function update(t) {
                requestAnimationFrame(update);
                debug.startFrame();

                const time = t * 0.001;
                program.uniforms.uTime.value = time;

                // Render ids to render target
                mesh.program.uniforms.uTargetRender.value = 1;
                mesh.program.setBlendFunc(gl.ONE, gl.ZERO);
                renderer.render({ scene: mesh, camera, target });

                // Read pixel data from target
                const data = new Uint8Array(4);
                gl.readPixels(
                    mouse.x,            // x
                    mouse.y,            // y
                    1,                  // width
                    1,                  // height
                    gl.RGBA,            // format
                    gl.UNSIGNED_BYTE,   // type
                    data
                );

                // Transform color back to id
                const id = data[0] + (data[1] << 8) + (data[2] << 16) + (data[3] << 24);

                if (id && objects[id - 1]) {
                    const data = objects[id - 1];
                    const [ rx, ry, rz ] = data.random;
                    highlight.scale.set(0.9 + ry * 0.2).scale(1.01);
                    highlight.rotation.set(0);
                    highlight.rotation.y = rx * 6.28 + 4 * time * (ry - 0.5);
                    highlight.position.set(data.offset);
                    highlight.visible = true;
                } else {
                    highlight.visible = false;
                }

                // Render to screen
                mesh.program.uniforms.uTargetRender.value = 0;
                mesh.program.setBlendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                renderer.render({ scene, camera });

                debug.endFrame();
            }

        </script>
    </body>
</html>